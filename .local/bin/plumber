#! /usr/bin/env elixir

defmodule ArgParser do
  def parse do
    {opts, _} =
      System.argv()
      |> OptionParser.parse!(strict: [option: :string, text: :string])

    options = [
      "First letter of each word in sentence",  #0
      "Single line of text",                    #1
      "Thesaurus",                              #2
      "KJV Verse Lookup"                        #3
    ]

    cond do
      opts[:option] == options |> Enum.at(0) ->
        TextPlumber.firstLetterOfWordsIn(opts[:text]) |> IO.binwrite()

      opts[:option] == options |> Enum.at(1) ->
        TextPlumber.singleLineOf(opts[:text]) |> IO.binwrite()

      opts[:option] == options |> Enum.at(2) ->
        TextPlumber.synonymOfFirstWordIn(opts[:text])
        TextPlumber.firstWordOf(opts[:text]) |> IO.binwrite()

      opts[:option] == options |> Enum.at(3) ->
        System.cmd("urxvt", ["-e", "sh", "-c", "kjv #{TextPlumber.singleLineOf(opts[:text])}"])
        TextPlumber.singleLineOf(opts[:text]) |> IO.binwrite()

      opts[:option] == "list" ->
        Enum.map(options, fn option -> IO.puts(option) end)

      true ->
        "No plumber #{opts[:option] || "specified"}." |> IO.puts()
    end
  end
end

defmodule TextPlumber do
  def firstLetterOfWordsIn(text) do
    String.replace(text, ~r/(\w)\w*/, "\\1", global: true)
    |> String.replace(~r/\s\s+/, " ", global: true)
  end

  def singleLineOf(text) do
    String.replace(text, "\n", " ")
    |> String.replace(~r/\s\s+/, " ", global: true)
  end

  def firstWordOf(text) do
    String.split(text) |> List.first()
  end

  def synonymOfFirstWordIn(text) do
    System.cmd("urxvt", ["-e", "sh", "-c", "dict #{TextPlumber.firstWordOf(text)} | vim -"])
  end
end

ArgParser.parse()
